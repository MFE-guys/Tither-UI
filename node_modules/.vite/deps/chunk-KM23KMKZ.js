import {
  CommonModule,
  DOCUMENT,
  DomAdapter,
  PLATFORM_BROWSER_ID,
  XhrFactory,
  getDOM,
  parseCookieValue,
  setRootDomAdapter
} from "./chunk-ZML4HEDM.js";
import {
  APP_ID,
  APP_INITIALIZER,
  ApplicationInitStatus,
  ApplicationModule,
  ApplicationRef,
  Console,
  ErrorHandler,
  FactoryTarget,
  INJECTOR_SCOPE,
  Inject,
  Injectable,
  InjectionToken,
  Injector,
  NgModule,
  NgZone,
  Optional,
  PLATFORM_ID,
  PLATFORM_INITIALIZER,
  RendererFactory2,
  RendererStyleFlags2,
  SecurityContext,
  SkipSelf,
  TESTABILITY,
  TESTABILITY_GETTER,
  Testability,
  TestabilityRegistry,
  Version,
  ViewEncapsulation$1,
  _global,
  _sanitizeHtml,
  _sanitizeUrl,
  allowSanitizationBypassAndThrow,
  bypassSanitizationTrustHtml,
  bypassSanitizationTrustResourceUrl,
  bypassSanitizationTrustScript,
  bypassSanitizationTrustStyle,
  bypassSanitizationTrustUrl,
  core_exports,
  createPlatformFactory,
  forwardRef,
  inject,
  internalCreateApplication,
  platformCore,
  setDocument,
  unwrapSafeValue,
  ɵɵinject,
  ɵɵngDeclareClassMetadata,
  ɵɵngDeclareFactory,
  ɵɵngDeclareInjectable,
  ɵɵngDeclareInjector,
  ɵɵngDeclareNgModule
} from "./chunk-4DHJIXX2.js";

// node_modules/@angular/platform-browser/fesm2015/platform-browser.mjs
var GenericBrowserDomAdapter = class extends DomAdapter {
  constructor() {
    super(...arguments);
    this.supportsDOMEvents = true;
  }
};
var BrowserDomAdapter = class extends GenericBrowserDomAdapter {
  static makeCurrent() {
    setRootDomAdapter(new BrowserDomAdapter());
  }
  onAndCancel(el, evt, listener) {
    el.addEventListener(evt, listener, false);
    return () => {
      el.removeEventListener(evt, listener, false);
    };
  }
  dispatchEvent(el, evt) {
    el.dispatchEvent(evt);
  }
  remove(node) {
    if (node.parentNode) {
      node.parentNode.removeChild(node);
    }
  }
  createElement(tagName, doc) {
    doc = doc || this.getDefaultDocument();
    return doc.createElement(tagName);
  }
  createHtmlDocument() {
    return document.implementation.createHTMLDocument("fakeTitle");
  }
  getDefaultDocument() {
    return document;
  }
  isElementNode(node) {
    return node.nodeType === Node.ELEMENT_NODE;
  }
  isShadowRoot(node) {
    return node instanceof DocumentFragment;
  }
  getGlobalEventTarget(doc, target) {
    if (target === "window") {
      return window;
    }
    if (target === "document") {
      return doc;
    }
    if (target === "body") {
      return doc.body;
    }
    return null;
  }
  getBaseHref(doc) {
    const href = getBaseElementHref();
    return href == null ? null : relativePath(href);
  }
  resetBaseElement() {
    baseElement = null;
  }
  getUserAgent() {
    return window.navigator.userAgent;
  }
  getCookie(name) {
    return parseCookieValue(document.cookie, name);
  }
};
var baseElement = null;
function getBaseElementHref() {
  baseElement = baseElement || document.querySelector("base");
  return baseElement ? baseElement.getAttribute("href") : null;
}
var urlParsingNode;
function relativePath(url) {
  urlParsingNode = urlParsingNode || document.createElement("a");
  urlParsingNode.setAttribute("href", url);
  const pathName = urlParsingNode.pathname;
  return pathName.charAt(0) === "/" ? pathName : `/${pathName}`;
}
var TRANSITION_ID = new InjectionToken("TRANSITION_ID");
function appInitializerFactory(transitionId, document2, injector) {
  return () => {
    injector.get(ApplicationInitStatus).donePromise.then(() => {
      const dom = getDOM();
      const styles = document2.querySelectorAll(`style[ng-transition="${transitionId}"]`);
      for (let i = 0; i < styles.length; i++) {
        dom.remove(styles[i]);
      }
    });
  };
}
var SERVER_TRANSITION_PROVIDERS = [
  {
    provide: APP_INITIALIZER,
    useFactory: appInitializerFactory,
    deps: [TRANSITION_ID, DOCUMENT, Injector],
    multi: true
  }
];
var BrowserGetTestability = class {
  addToWindow(registry) {
    _global["getAngularTestability"] = (elem, findInAncestors = true) => {
      const testability = registry.findTestabilityInTree(elem, findInAncestors);
      if (testability == null) {
        throw new Error("Could not find testability for element.");
      }
      return testability;
    };
    _global["getAllAngularTestabilities"] = () => registry.getAllTestabilities();
    _global["getAllAngularRootElements"] = () => registry.getAllRootElements();
    const whenAllStable = (callback) => {
      const testabilities = _global["getAllAngularTestabilities"]();
      let count = testabilities.length;
      let didWork = false;
      const decrement = function(didWork_) {
        didWork = didWork || didWork_;
        count--;
        if (count == 0) {
          callback(didWork);
        }
      };
      testabilities.forEach(function(testability) {
        testability.whenStable(decrement);
      });
    };
    if (!_global["frameworkStabilizers"]) {
      _global["frameworkStabilizers"] = [];
    }
    _global["frameworkStabilizers"].push(whenAllStable);
  }
  findTestabilityInTree(registry, elem, findInAncestors) {
    if (elem == null) {
      return null;
    }
    const t = registry.getTestability(elem);
    if (t != null) {
      return t;
    } else if (!findInAncestors) {
      return null;
    }
    if (getDOM().isShadowRoot(elem)) {
      return this.findTestabilityInTree(registry, elem.host, true);
    }
    return this.findTestabilityInTree(registry, elem.parentElement, true);
  }
};
var BrowserXhr = class {
  build() {
    return new XMLHttpRequest();
  }
};
BrowserXhr.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "15.0.0-next.6", ngImport: core_exports, type: BrowserXhr, deps: [], target: FactoryTarget.Injectable });
BrowserXhr.\u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "15.0.0-next.6", ngImport: core_exports, type: BrowserXhr });
\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.0-next.6", ngImport: core_exports, type: BrowserXhr, decorators: [{
  type: Injectable
}] });
var EVENT_MANAGER_PLUGINS = new InjectionToken("EventManagerPlugins");
var EventManager = class {
  constructor(plugins, _zone) {
    this._zone = _zone;
    this._eventNameToPlugin = /* @__PURE__ */ new Map();
    plugins.forEach((p) => p.manager = this);
    this._plugins = plugins.slice().reverse();
  }
  addEventListener(element, eventName, handler) {
    const plugin = this._findPluginFor(eventName);
    return plugin.addEventListener(element, eventName, handler);
  }
  addGlobalEventListener(target, eventName, handler) {
    const plugin = this._findPluginFor(eventName);
    return plugin.addGlobalEventListener(target, eventName, handler);
  }
  getZone() {
    return this._zone;
  }
  _findPluginFor(eventName) {
    const plugin = this._eventNameToPlugin.get(eventName);
    if (plugin) {
      return plugin;
    }
    const plugins = this._plugins;
    for (let i = 0; i < plugins.length; i++) {
      const plugin2 = plugins[i];
      if (plugin2.supports(eventName)) {
        this._eventNameToPlugin.set(eventName, plugin2);
        return plugin2;
      }
    }
    throw new Error(`No event manager plugin found for event ${eventName}`);
  }
};
EventManager.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "15.0.0-next.6", ngImport: core_exports, type: EventManager, deps: [{ token: EVENT_MANAGER_PLUGINS }, { token: NgZone }], target: FactoryTarget.Injectable });
EventManager.\u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "15.0.0-next.6", ngImport: core_exports, type: EventManager });
\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.0-next.6", ngImport: core_exports, type: EventManager, decorators: [{
  type: Injectable
}], ctorParameters: function() {
  return [{ type: void 0, decorators: [{
    type: Inject,
    args: [EVENT_MANAGER_PLUGINS]
  }] }, { type: NgZone }];
} });
var EventManagerPlugin = class {
  constructor(_doc) {
    this._doc = _doc;
  }
  addGlobalEventListener(element, eventName, handler) {
    const target = getDOM().getGlobalEventTarget(this._doc, element);
    if (!target) {
      throw new Error(`Unsupported event target ${target} for event ${eventName}`);
    }
    return this.addEventListener(target, eventName, handler);
  }
};
var SharedStylesHost = class {
  constructor() {
    this._stylesSet = /* @__PURE__ */ new Set();
  }
  addStyles(styles) {
    const additions = /* @__PURE__ */ new Set();
    styles.forEach((style) => {
      if (!this._stylesSet.has(style)) {
        this._stylesSet.add(style);
        additions.add(style);
      }
    });
    this.onStylesAdded(additions);
  }
  onStylesAdded(additions) {
  }
  getAllStyles() {
    return Array.from(this._stylesSet);
  }
};
SharedStylesHost.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "15.0.0-next.6", ngImport: core_exports, type: SharedStylesHost, deps: [], target: FactoryTarget.Injectable });
SharedStylesHost.\u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "15.0.0-next.6", ngImport: core_exports, type: SharedStylesHost });
\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.0-next.6", ngImport: core_exports, type: SharedStylesHost, decorators: [{
  type: Injectable
}] });
var DomSharedStylesHost = class extends SharedStylesHost {
  constructor(_doc) {
    super();
    this._doc = _doc;
    this._hostNodes = /* @__PURE__ */ new Map();
    this._hostNodes.set(_doc.head, []);
  }
  _addStylesToHost(styles, host, styleNodes) {
    styles.forEach((style) => {
      const styleEl = this._doc.createElement("style");
      styleEl.textContent = style;
      styleNodes.push(host.appendChild(styleEl));
    });
  }
  addHost(hostNode) {
    const styleNodes = [];
    this._addStylesToHost(this._stylesSet, hostNode, styleNodes);
    this._hostNodes.set(hostNode, styleNodes);
  }
  removeHost(hostNode) {
    const styleNodes = this._hostNodes.get(hostNode);
    if (styleNodes) {
      styleNodes.forEach(removeStyle);
    }
    this._hostNodes.delete(hostNode);
  }
  onStylesAdded(additions) {
    this._hostNodes.forEach((styleNodes, hostNode) => {
      this._addStylesToHost(additions, hostNode, styleNodes);
    });
  }
  ngOnDestroy() {
    this._hostNodes.forEach((styleNodes) => styleNodes.forEach(removeStyle));
  }
};
DomSharedStylesHost.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "15.0.0-next.6", ngImport: core_exports, type: DomSharedStylesHost, deps: [{ token: DOCUMENT }], target: FactoryTarget.Injectable });
DomSharedStylesHost.\u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "15.0.0-next.6", ngImport: core_exports, type: DomSharedStylesHost });
\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.0-next.6", ngImport: core_exports, type: DomSharedStylesHost, decorators: [{
  type: Injectable
}], ctorParameters: function() {
  return [{ type: void 0, decorators: [{
    type: Inject,
    args: [DOCUMENT]
  }] }];
} });
function removeStyle(styleNode) {
  getDOM().remove(styleNode);
}
var NAMESPACE_URIS = {
  "svg": "http://www.w3.org/2000/svg",
  "xhtml": "http://www.w3.org/1999/xhtml",
  "xlink": "http://www.w3.org/1999/xlink",
  "xml": "http://www.w3.org/XML/1998/namespace",
  "xmlns": "http://www.w3.org/2000/xmlns/",
  "math": "http://www.w3.org/1998/MathML/"
};
var COMPONENT_REGEX = /%COMP%/g;
var NG_DEV_MODE$1 = typeof ngDevMode === "undefined" || !!ngDevMode;
var COMPONENT_VARIABLE = "%COMP%";
var HOST_ATTR = `_nghost-${COMPONENT_VARIABLE}`;
var CONTENT_ATTR = `_ngcontent-${COMPONENT_VARIABLE}`;
function shimContentAttribute(componentShortId) {
  return CONTENT_ATTR.replace(COMPONENT_REGEX, componentShortId);
}
function shimHostAttribute(componentShortId) {
  return HOST_ATTR.replace(COMPONENT_REGEX, componentShortId);
}
function flattenStyles(compId, styles, target) {
  for (let i = 0; i < styles.length; i++) {
    let style = styles[i];
    if (Array.isArray(style)) {
      flattenStyles(compId, style, target);
    } else {
      style = style.replace(COMPONENT_REGEX, compId);
      target.push(style);
    }
  }
  return target;
}
function decoratePreventDefault(eventHandler) {
  return (event) => {
    if (event === "__ngUnwrap__") {
      return eventHandler;
    }
    const allowDefaultBehavior = eventHandler(event);
    if (allowDefaultBehavior === false) {
      event.preventDefault();
      event.returnValue = false;
    }
    return void 0;
  };
}
var hasLoggedNativeEncapsulationWarning = false;
var DomRendererFactory2 = class {
  constructor(eventManager, sharedStylesHost, appId) {
    this.eventManager = eventManager;
    this.sharedStylesHost = sharedStylesHost;
    this.appId = appId;
    this.rendererByCompId = /* @__PURE__ */ new Map();
    this.defaultRenderer = new DefaultDomRenderer2(eventManager);
  }
  createRenderer(element, type) {
    if (!element || !type) {
      return this.defaultRenderer;
    }
    switch (type.encapsulation) {
      case ViewEncapsulation$1.Emulated: {
        let renderer = this.rendererByCompId.get(type.id);
        if (!renderer) {
          renderer = new EmulatedEncapsulationDomRenderer2(this.eventManager, this.sharedStylesHost, type, this.appId);
          this.rendererByCompId.set(type.id, renderer);
        }
        renderer.applyToHost(element);
        return renderer;
      }
      case 1:
      case ViewEncapsulation$1.ShadowDom:
        if ((typeof ngDevMode === "undefined" || ngDevMode) && !hasLoggedNativeEncapsulationWarning && type.encapsulation === 1) {
          hasLoggedNativeEncapsulationWarning = true;
          console.warn("ViewEncapsulation.Native is no longer supported. Falling back to ViewEncapsulation.ShadowDom. The fallback will be removed in v12.");
        }
        return new ShadowDomRenderer(this.eventManager, this.sharedStylesHost, element, type);
      default: {
        if (!this.rendererByCompId.has(type.id)) {
          const styles = flattenStyles(type.id, type.styles, []);
          this.sharedStylesHost.addStyles(styles);
          this.rendererByCompId.set(type.id, this.defaultRenderer);
        }
        return this.defaultRenderer;
      }
    }
  }
  begin() {
  }
  end() {
  }
};
DomRendererFactory2.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "15.0.0-next.6", ngImport: core_exports, type: DomRendererFactory2, deps: [{ token: EventManager }, { token: DomSharedStylesHost }, { token: APP_ID }], target: FactoryTarget.Injectable });
DomRendererFactory2.\u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "15.0.0-next.6", ngImport: core_exports, type: DomRendererFactory2 });
\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.0-next.6", ngImport: core_exports, type: DomRendererFactory2, decorators: [{
  type: Injectable
}], ctorParameters: function() {
  return [{ type: EventManager }, { type: DomSharedStylesHost }, { type: void 0, decorators: [{
    type: Inject,
    args: [APP_ID]
  }] }];
} });
var DefaultDomRenderer2 = class {
  constructor(eventManager) {
    this.eventManager = eventManager;
    this.data = /* @__PURE__ */ Object.create(null);
    this.destroyNode = null;
  }
  destroy() {
  }
  createElement(name, namespace) {
    if (namespace) {
      return document.createElementNS(NAMESPACE_URIS[namespace] || namespace, name);
    }
    return document.createElement(name);
  }
  createComment(value) {
    return document.createComment(value);
  }
  createText(value) {
    return document.createTextNode(value);
  }
  appendChild(parent, newChild) {
    const targetParent = isTemplateNode(parent) ? parent.content : parent;
    targetParent.appendChild(newChild);
  }
  insertBefore(parent, newChild, refChild) {
    if (parent) {
      const targetParent = isTemplateNode(parent) ? parent.content : parent;
      targetParent.insertBefore(newChild, refChild);
    }
  }
  removeChild(parent, oldChild) {
    if (parent) {
      parent.removeChild(oldChild);
    }
  }
  selectRootElement(selectorOrNode, preserveContent) {
    let el = typeof selectorOrNode === "string" ? document.querySelector(selectorOrNode) : selectorOrNode;
    if (!el) {
      throw new Error(`The selector "${selectorOrNode}" did not match any elements`);
    }
    if (!preserveContent) {
      el.textContent = "";
    }
    return el;
  }
  parentNode(node) {
    return node.parentNode;
  }
  nextSibling(node) {
    return node.nextSibling;
  }
  setAttribute(el, name, value, namespace) {
    if (namespace) {
      name = namespace + ":" + name;
      const namespaceUri = NAMESPACE_URIS[namespace];
      if (namespaceUri) {
        el.setAttributeNS(namespaceUri, name, value);
      } else {
        el.setAttribute(name, value);
      }
    } else {
      el.setAttribute(name, value);
    }
  }
  removeAttribute(el, name, namespace) {
    if (namespace) {
      const namespaceUri = NAMESPACE_URIS[namespace];
      if (namespaceUri) {
        el.removeAttributeNS(namespaceUri, name);
      } else {
        el.removeAttribute(`${namespace}:${name}`);
      }
    } else {
      el.removeAttribute(name);
    }
  }
  addClass(el, name) {
    el.classList.add(name);
  }
  removeClass(el, name) {
    el.classList.remove(name);
  }
  setStyle(el, style, value, flags) {
    if (flags & (RendererStyleFlags2.DashCase | RendererStyleFlags2.Important)) {
      el.style.setProperty(style, value, flags & RendererStyleFlags2.Important ? "important" : "");
    } else {
      el.style[style] = value;
    }
  }
  removeStyle(el, style, flags) {
    if (flags & RendererStyleFlags2.DashCase) {
      el.style.removeProperty(style);
    } else {
      el.style[style] = "";
    }
  }
  setProperty(el, name, value) {
    NG_DEV_MODE$1 && checkNoSyntheticProp(name, "property");
    el[name] = value;
  }
  setValue(node, value) {
    node.nodeValue = value;
  }
  listen(target, event, callback) {
    NG_DEV_MODE$1 && checkNoSyntheticProp(event, "listener");
    if (typeof target === "string") {
      return this.eventManager.addGlobalEventListener(target, event, decoratePreventDefault(callback));
    }
    return this.eventManager.addEventListener(target, event, decoratePreventDefault(callback));
  }
};
var AT_CHARCODE = (() => "@".charCodeAt(0))();
function checkNoSyntheticProp(name, nameKind) {
  if (name.charCodeAt(0) === AT_CHARCODE) {
    throw new Error(`Unexpected synthetic ${nameKind} ${name} found. Please make sure that:
  - Either \`BrowserAnimationsModule\` or \`NoopAnimationsModule\` are imported in your application.
  - There is corresponding configuration for the animation named \`${name}\` defined in the \`animations\` field of the \`@Component\` decorator (see https://angular.io/api/core/Component#animations).`);
  }
}
function isTemplateNode(node) {
  return node.tagName === "TEMPLATE" && node.content !== void 0;
}
var EmulatedEncapsulationDomRenderer2 = class extends DefaultDomRenderer2 {
  constructor(eventManager, sharedStylesHost, component, appId) {
    super(eventManager);
    this.component = component;
    const styles = flattenStyles(appId + "-" + component.id, component.styles, []);
    sharedStylesHost.addStyles(styles);
    this.contentAttr = shimContentAttribute(appId + "-" + component.id);
    this.hostAttr = shimHostAttribute(appId + "-" + component.id);
  }
  applyToHost(element) {
    super.setAttribute(element, this.hostAttr, "");
  }
  createElement(parent, name) {
    const el = super.createElement(parent, name);
    super.setAttribute(el, this.contentAttr, "");
    return el;
  }
};
var ShadowDomRenderer = class extends DefaultDomRenderer2 {
  constructor(eventManager, sharedStylesHost, hostEl, component) {
    super(eventManager);
    this.sharedStylesHost = sharedStylesHost;
    this.hostEl = hostEl;
    this.shadowRoot = hostEl.attachShadow({ mode: "open" });
    this.sharedStylesHost.addHost(this.shadowRoot);
    const styles = flattenStyles(component.id, component.styles, []);
    for (let i = 0; i < styles.length; i++) {
      const styleEl = document.createElement("style");
      styleEl.textContent = styles[i];
      this.shadowRoot.appendChild(styleEl);
    }
  }
  nodeOrShadowRoot(node) {
    return node === this.hostEl ? this.shadowRoot : node;
  }
  destroy() {
    this.sharedStylesHost.removeHost(this.shadowRoot);
  }
  appendChild(parent, newChild) {
    return super.appendChild(this.nodeOrShadowRoot(parent), newChild);
  }
  insertBefore(parent, newChild, refChild) {
    return super.insertBefore(this.nodeOrShadowRoot(parent), newChild, refChild);
  }
  removeChild(parent, oldChild) {
    return super.removeChild(this.nodeOrShadowRoot(parent), oldChild);
  }
  parentNode(node) {
    return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(node)));
  }
};
var DomEventsPlugin = class extends EventManagerPlugin {
  constructor(doc) {
    super(doc);
  }
  supports(eventName) {
    return true;
  }
  addEventListener(element, eventName, handler) {
    element.addEventListener(eventName, handler, false);
    return () => this.removeEventListener(element, eventName, handler);
  }
  removeEventListener(target, eventName, callback) {
    return target.removeEventListener(eventName, callback);
  }
};
DomEventsPlugin.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "15.0.0-next.6", ngImport: core_exports, type: DomEventsPlugin, deps: [{ token: DOCUMENT }], target: FactoryTarget.Injectable });
DomEventsPlugin.\u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "15.0.0-next.6", ngImport: core_exports, type: DomEventsPlugin });
\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.0-next.6", ngImport: core_exports, type: DomEventsPlugin, decorators: [{
  type: Injectable
}], ctorParameters: function() {
  return [{ type: void 0, decorators: [{
    type: Inject,
    args: [DOCUMENT]
  }] }];
} });
var MODIFIER_KEYS = ["alt", "control", "meta", "shift"];
var _keyMap = {
  "\b": "Backspace",
  "	": "Tab",
  "\x7F": "Delete",
  "\x1B": "Escape",
  "Del": "Delete",
  "Esc": "Escape",
  "Left": "ArrowLeft",
  "Right": "ArrowRight",
  "Up": "ArrowUp",
  "Down": "ArrowDown",
  "Menu": "ContextMenu",
  "Scroll": "ScrollLock",
  "Win": "OS"
};
var MODIFIER_KEY_GETTERS = {
  "alt": (event) => event.altKey,
  "control": (event) => event.ctrlKey,
  "meta": (event) => event.metaKey,
  "shift": (event) => event.shiftKey
};
var KeyEventsPlugin = class extends EventManagerPlugin {
  constructor(doc) {
    super(doc);
  }
  supports(eventName) {
    return KeyEventsPlugin.parseEventName(eventName) != null;
  }
  addEventListener(element, eventName, handler) {
    const parsedEvent = KeyEventsPlugin.parseEventName(eventName);
    const outsideHandler = KeyEventsPlugin.eventCallback(parsedEvent["fullKey"], handler, this.manager.getZone());
    return this.manager.getZone().runOutsideAngular(() => {
      return getDOM().onAndCancel(element, parsedEvent["domEventName"], outsideHandler);
    });
  }
  static parseEventName(eventName) {
    const parts = eventName.toLowerCase().split(".");
    const domEventName = parts.shift();
    if (parts.length === 0 || !(domEventName === "keydown" || domEventName === "keyup")) {
      return null;
    }
    const key = KeyEventsPlugin._normalizeKey(parts.pop());
    let fullKey = "";
    let codeIX = parts.indexOf("code");
    if (codeIX > -1) {
      parts.splice(codeIX, 1);
      fullKey = "code.";
    }
    MODIFIER_KEYS.forEach((modifierName) => {
      const index = parts.indexOf(modifierName);
      if (index > -1) {
        parts.splice(index, 1);
        fullKey += modifierName + ".";
      }
    });
    fullKey += key;
    if (parts.length != 0 || key.length === 0) {
      return null;
    }
    const result = {};
    result["domEventName"] = domEventName;
    result["fullKey"] = fullKey;
    return result;
  }
  static matchEventFullKeyCode(event, fullKeyCode) {
    let keycode = _keyMap[event.key] || event.key;
    let key = "";
    if (fullKeyCode.indexOf("code.") > -1) {
      keycode = event.code;
      key = "code.";
    }
    if (keycode == null || !keycode)
      return false;
    keycode = keycode.toLowerCase();
    if (keycode === " ") {
      keycode = "space";
    } else if (keycode === ".") {
      keycode = "dot";
    }
    MODIFIER_KEYS.forEach((modifierName) => {
      if (modifierName !== keycode) {
        const modifierGetter = MODIFIER_KEY_GETTERS[modifierName];
        if (modifierGetter(event)) {
          key += modifierName + ".";
        }
      }
    });
    key += keycode;
    return key === fullKeyCode;
  }
  static eventCallback(fullKey, handler, zone) {
    return (event) => {
      if (KeyEventsPlugin.matchEventFullKeyCode(event, fullKey)) {
        zone.runGuarded(() => handler(event));
      }
    };
  }
  static _normalizeKey(keyName) {
    switch (keyName) {
      case "esc":
        return "escape";
      default:
        return keyName;
    }
  }
};
KeyEventsPlugin.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "15.0.0-next.6", ngImport: core_exports, type: KeyEventsPlugin, deps: [{ token: DOCUMENT }], target: FactoryTarget.Injectable });
KeyEventsPlugin.\u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "15.0.0-next.6", ngImport: core_exports, type: KeyEventsPlugin });
\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.0-next.6", ngImport: core_exports, type: KeyEventsPlugin, decorators: [{
  type: Injectable
}], ctorParameters: function() {
  return [{ type: void 0, decorators: [{
    type: Inject,
    args: [DOCUMENT]
  }] }];
} });
var NG_DEV_MODE = typeof ngDevMode === "undefined" || !!ngDevMode;
function bootstrapApplication(rootComponent, options) {
  return internalCreateApplication(Object.assign({ rootComponent }, createProvidersConfig(options)));
}
function createApplication(options) {
  return internalCreateApplication(createProvidersConfig(options));
}
function createProvidersConfig(options) {
  var _a;
  return {
    appProviders: [
      ...BROWSER_MODULE_PROVIDERS,
      ...(_a = options === null || options === void 0 ? void 0 : options.providers) !== null && _a !== void 0 ? _a : []
    ],
    platformProviders: INTERNAL_BROWSER_PLATFORM_PROVIDERS
  };
}
function provideProtractorTestingSupport() {
  return [...TESTABILITY_PROVIDERS];
}
function initDomAdapter() {
  BrowserDomAdapter.makeCurrent();
}
function errorHandler() {
  return new ErrorHandler();
}
function _document() {
  setDocument(document);
  return document;
}
var INTERNAL_BROWSER_PLATFORM_PROVIDERS = [
  { provide: PLATFORM_ID, useValue: PLATFORM_BROWSER_ID },
  { provide: PLATFORM_INITIALIZER, useValue: initDomAdapter, multi: true },
  { provide: DOCUMENT, useFactory: _document, deps: [] }
];
var platformBrowser = createPlatformFactory(platformCore, "browser", INTERNAL_BROWSER_PLATFORM_PROVIDERS);
var BROWSER_MODULE_PROVIDERS_MARKER = new InjectionToken(NG_DEV_MODE ? "BrowserModule Providers Marker" : "");
var TESTABILITY_PROVIDERS = [
  {
    provide: TESTABILITY_GETTER,
    useClass: BrowserGetTestability,
    deps: []
  },
  {
    provide: TESTABILITY,
    useClass: Testability,
    deps: [NgZone, TestabilityRegistry, TESTABILITY_GETTER]
  },
  {
    provide: Testability,
    useClass: Testability,
    deps: [NgZone, TestabilityRegistry, TESTABILITY_GETTER]
  }
];
var BROWSER_MODULE_PROVIDERS = [
  { provide: INJECTOR_SCOPE, useValue: "root" },
  { provide: ErrorHandler, useFactory: errorHandler, deps: [] },
  {
    provide: EVENT_MANAGER_PLUGINS,
    useClass: DomEventsPlugin,
    multi: true,
    deps: [DOCUMENT, NgZone, PLATFORM_ID]
  },
  { provide: EVENT_MANAGER_PLUGINS, useClass: KeyEventsPlugin, multi: true, deps: [DOCUMENT] },
  {
    provide: DomRendererFactory2,
    useClass: DomRendererFactory2,
    deps: [EventManager, DomSharedStylesHost, APP_ID]
  },
  { provide: RendererFactory2, useExisting: DomRendererFactory2 },
  { provide: SharedStylesHost, useExisting: DomSharedStylesHost },
  { provide: DomSharedStylesHost, useClass: DomSharedStylesHost, deps: [DOCUMENT] },
  { provide: EventManager, useClass: EventManager, deps: [EVENT_MANAGER_PLUGINS, NgZone] },
  { provide: XhrFactory, useClass: BrowserXhr, deps: [] },
  NG_DEV_MODE ? { provide: BROWSER_MODULE_PROVIDERS_MARKER, useValue: true } : []
];
var BrowserModule = class {
  constructor(providersAlreadyPresent) {
    if (NG_DEV_MODE && providersAlreadyPresent) {
      throw new Error(`Providers from the \`BrowserModule\` have already been loaded. If you need access to common directives such as NgIf and NgFor, import the \`CommonModule\` instead.`);
    }
  }
  static withServerTransition(params) {
    return {
      ngModule: BrowserModule,
      providers: [
        { provide: APP_ID, useValue: params.appId },
        { provide: TRANSITION_ID, useExisting: APP_ID },
        SERVER_TRANSITION_PROVIDERS
      ]
    };
  }
};
BrowserModule.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "15.0.0-next.6", ngImport: core_exports, type: BrowserModule, deps: [{ token: BROWSER_MODULE_PROVIDERS_MARKER, optional: true, skipSelf: true }], target: FactoryTarget.NgModule });
BrowserModule.\u0275mod = \u0275\u0275ngDeclareNgModule({ minVersion: "14.0.0", version: "15.0.0-next.6", ngImport: core_exports, type: BrowserModule, exports: [CommonModule, ApplicationModule] });
BrowserModule.\u0275inj = \u0275\u0275ngDeclareInjector({ minVersion: "12.0.0", version: "15.0.0-next.6", ngImport: core_exports, type: BrowserModule, providers: [
  ...BROWSER_MODULE_PROVIDERS,
  ...TESTABILITY_PROVIDERS
], imports: [CommonModule, ApplicationModule] });
\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.0-next.6", ngImport: core_exports, type: BrowserModule, decorators: [{
  type: NgModule,
  args: [{
    providers: [
      ...BROWSER_MODULE_PROVIDERS,
      ...TESTABILITY_PROVIDERS
    ],
    exports: [CommonModule, ApplicationModule]
  }]
}], ctorParameters: function() {
  return [{ type: void 0, decorators: [{
    type: Optional
  }, {
    type: SkipSelf
  }, {
    type: Inject,
    args: [BROWSER_MODULE_PROVIDERS_MARKER]
  }] }];
} });
function createMeta() {
  return new Meta(\u0275\u0275inject(DOCUMENT));
}
var Meta = class {
  constructor(_doc) {
    this._doc = _doc;
    this._dom = getDOM();
  }
  addTag(tag, forceCreation = false) {
    if (!tag)
      return null;
    return this._getOrCreateElement(tag, forceCreation);
  }
  addTags(tags, forceCreation = false) {
    if (!tags)
      return [];
    return tags.reduce((result, tag) => {
      if (tag) {
        result.push(this._getOrCreateElement(tag, forceCreation));
      }
      return result;
    }, []);
  }
  getTag(attrSelector) {
    if (!attrSelector)
      return null;
    return this._doc.querySelector(`meta[${attrSelector}]`) || null;
  }
  getTags(attrSelector) {
    if (!attrSelector)
      return [];
    const list = this._doc.querySelectorAll(`meta[${attrSelector}]`);
    return list ? [].slice.call(list) : [];
  }
  updateTag(tag, selector) {
    if (!tag)
      return null;
    selector = selector || this._parseSelector(tag);
    const meta = this.getTag(selector);
    if (meta) {
      return this._setMetaElementAttributes(tag, meta);
    }
    return this._getOrCreateElement(tag, true);
  }
  removeTag(attrSelector) {
    this.removeTagElement(this.getTag(attrSelector));
  }
  removeTagElement(meta) {
    if (meta) {
      this._dom.remove(meta);
    }
  }
  _getOrCreateElement(meta, forceCreation = false) {
    if (!forceCreation) {
      const selector = this._parseSelector(meta);
      const elem = this.getTags(selector).filter((elem2) => this._containsAttributes(meta, elem2))[0];
      if (elem !== void 0)
        return elem;
    }
    const element = this._dom.createElement("meta");
    this._setMetaElementAttributes(meta, element);
    const head = this._doc.getElementsByTagName("head")[0];
    head.appendChild(element);
    return element;
  }
  _setMetaElementAttributes(tag, el) {
    Object.keys(tag).forEach((prop) => el.setAttribute(this._getMetaKeyMap(prop), tag[prop]));
    return el;
  }
  _parseSelector(tag) {
    const attr = tag.name ? "name" : "property";
    return `${attr}="${tag[attr]}"`;
  }
  _containsAttributes(tag, elem) {
    return Object.keys(tag).every((key) => elem.getAttribute(this._getMetaKeyMap(key)) === tag[key]);
  }
  _getMetaKeyMap(prop) {
    return META_KEYS_MAP[prop] || prop;
  }
};
Meta.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "15.0.0-next.6", ngImport: core_exports, type: Meta, deps: [{ token: DOCUMENT }], target: FactoryTarget.Injectable });
Meta.\u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "15.0.0-next.6", ngImport: core_exports, type: Meta, providedIn: "root", useFactory: createMeta, deps: [] });
\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.0-next.6", ngImport: core_exports, type: Meta, decorators: [{
  type: Injectable,
  args: [{ providedIn: "root", useFactory: createMeta, deps: [] }]
}], ctorParameters: function() {
  return [{ type: void 0, decorators: [{
    type: Inject,
    args: [DOCUMENT]
  }] }];
} });
var META_KEYS_MAP = {
  httpEquiv: "http-equiv"
};
function createTitle() {
  return new Title(\u0275\u0275inject(DOCUMENT));
}
var Title = class {
  constructor(_doc) {
    this._doc = _doc;
  }
  getTitle() {
    return this._doc.title;
  }
  setTitle(newTitle) {
    this._doc.title = newTitle || "";
  }
};
Title.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "15.0.0-next.6", ngImport: core_exports, type: Title, deps: [{ token: DOCUMENT }], target: FactoryTarget.Injectable });
Title.\u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "15.0.0-next.6", ngImport: core_exports, type: Title, providedIn: "root", useFactory: createTitle, deps: [] });
\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.0-next.6", ngImport: core_exports, type: Title, decorators: [{
  type: Injectable,
  args: [{ providedIn: "root", useFactory: createTitle, deps: [] }]
}], ctorParameters: function() {
  return [{ type: void 0, decorators: [{
    type: Inject,
    args: [DOCUMENT]
  }] }];
} });
function exportNgVar(name, value) {
  if (typeof COMPILED === "undefined" || !COMPILED) {
    const ng = _global["ng"] = _global["ng"] || {};
    ng[name] = value;
  }
}
var win = typeof window !== "undefined" && window || {};
var ChangeDetectionPerfRecord = class {
  constructor(msPerTick, numTicks) {
    this.msPerTick = msPerTick;
    this.numTicks = numTicks;
  }
};
var AngularProfiler = class {
  constructor(ref) {
    this.appRef = ref.injector.get(ApplicationRef);
  }
  timeChangeDetection(config) {
    const record = config && config["record"];
    const profileName = "Change Detection";
    const isProfilerAvailable = win.console.profile != null;
    if (record && isProfilerAvailable) {
      win.console.profile(profileName);
    }
    const start = performanceNow();
    let numTicks = 0;
    while (numTicks < 5 || performanceNow() - start < 500) {
      this.appRef.tick();
      numTicks++;
    }
    const end = performanceNow();
    if (record && isProfilerAvailable) {
      win.console.profileEnd(profileName);
    }
    const msPerTick = (end - start) / numTicks;
    win.console.log(`ran ${numTicks} change detection cycles`);
    win.console.log(`${msPerTick.toFixed(2)} ms per check`);
    return new ChangeDetectionPerfRecord(msPerTick, numTicks);
  }
};
function performanceNow() {
  return win.performance && win.performance.now ? win.performance.now() : new Date().getTime();
}
var PROFILER_GLOBAL_NAME = "profiler";
function enableDebugTools(ref) {
  exportNgVar(PROFILER_GLOBAL_NAME, new AngularProfiler(ref));
  return ref;
}
function disableDebugTools() {
  exportNgVar(PROFILER_GLOBAL_NAME, null);
}
function escapeHtml(text) {
  const escapedText = {
    "&": "&a;",
    '"': "&q;",
    "'": "&s;",
    "<": "&l;",
    ">": "&g;"
  };
  return text.replace(/[&"'<>]/g, (s) => escapedText[s]);
}
function unescapeHtml(text) {
  const unescapedText = {
    "&a;": "&",
    "&q;": '"',
    "&s;": "'",
    "&l;": "<",
    "&g;": ">"
  };
  return text.replace(/&[^;]+;/g, (s) => unescapedText[s]);
}
function makeStateKey(key) {
  return key;
}
var TransferState = class {
  constructor() {
    this.store = {};
    this.onSerializeCallbacks = {};
  }
  get(key, defaultValue) {
    return this.store[key] !== void 0 ? this.store[key] : defaultValue;
  }
  set(key, value) {
    this.store[key] = value;
  }
  remove(key) {
    delete this.store[key];
  }
  hasKey(key) {
    return this.store.hasOwnProperty(key);
  }
  get isEmpty() {
    return Object.keys(this.store).length === 0;
  }
  onSerialize(key, callback) {
    this.onSerializeCallbacks[key] = callback;
  }
  toJson() {
    for (const key in this.onSerializeCallbacks) {
      if (this.onSerializeCallbacks.hasOwnProperty(key)) {
        try {
          this.store[key] = this.onSerializeCallbacks[key]();
        } catch (e) {
          console.warn("Exception in onSerialize callback: ", e);
        }
      }
    }
    return JSON.stringify(this.store);
  }
};
TransferState.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "15.0.0-next.6", ngImport: core_exports, type: TransferState, deps: [], target: FactoryTarget.Injectable });
TransferState.\u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "15.0.0-next.6", ngImport: core_exports, type: TransferState, providedIn: "root", useFactory: () => {
  const doc = inject(DOCUMENT);
  const appId = inject(APP_ID);
  const state = new TransferState();
  state.store = retrieveTransferredState(doc, appId);
  return state;
} });
\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.0-next.6", ngImport: core_exports, type: TransferState, decorators: [{
  type: Injectable,
  args: [{
    providedIn: "root",
    useFactory: () => {
      const doc = inject(DOCUMENT);
      const appId = inject(APP_ID);
      const state = new TransferState();
      state.store = retrieveTransferredState(doc, appId);
      return state;
    }
  }]
}] });
function retrieveTransferredState(doc, appId) {
  const script = doc.getElementById(appId + "-state");
  let initialState = {};
  if (script && script.textContent) {
    try {
      initialState = JSON.parse(unescapeHtml(script.textContent));
    } catch (e) {
      console.warn("Exception while restoring TransferState for app " + appId, e);
    }
  }
  return initialState;
}
var BrowserTransferStateModule = class {
};
BrowserTransferStateModule.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "15.0.0-next.6", ngImport: core_exports, type: BrowserTransferStateModule, deps: [], target: FactoryTarget.NgModule });
BrowserTransferStateModule.\u0275mod = \u0275\u0275ngDeclareNgModule({ minVersion: "14.0.0", version: "15.0.0-next.6", ngImport: core_exports, type: BrowserTransferStateModule });
BrowserTransferStateModule.\u0275inj = \u0275\u0275ngDeclareInjector({ minVersion: "12.0.0", version: "15.0.0-next.6", ngImport: core_exports, type: BrowserTransferStateModule });
\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.0-next.6", ngImport: core_exports, type: BrowserTransferStateModule, decorators: [{
  type: NgModule,
  args: [{}]
}] });
var By = class {
  static all() {
    return () => true;
  }
  static css(selector) {
    return (debugElement) => {
      return debugElement.nativeElement != null ? elementMatches(debugElement.nativeElement, selector) : false;
    };
  }
  static directive(type) {
    return (debugNode) => debugNode.providerTokens.indexOf(type) !== -1;
  }
};
function elementMatches(n, selector) {
  if (getDOM().isElementNode(n)) {
    return n.matches && n.matches(selector) || n.msMatchesSelector && n.msMatchesSelector(selector) || n.webkitMatchesSelector && n.webkitMatchesSelector(selector);
  }
  return false;
}
var EVENT_NAMES = {
  "pan": true,
  "panstart": true,
  "panmove": true,
  "panend": true,
  "pancancel": true,
  "panleft": true,
  "panright": true,
  "panup": true,
  "pandown": true,
  "pinch": true,
  "pinchstart": true,
  "pinchmove": true,
  "pinchend": true,
  "pinchcancel": true,
  "pinchin": true,
  "pinchout": true,
  "press": true,
  "pressup": true,
  "rotate": true,
  "rotatestart": true,
  "rotatemove": true,
  "rotateend": true,
  "rotatecancel": true,
  "swipe": true,
  "swipeleft": true,
  "swiperight": true,
  "swipeup": true,
  "swipedown": true,
  "tap": true,
  "doubletap": true
};
var HAMMER_GESTURE_CONFIG = new InjectionToken("HammerGestureConfig");
var HAMMER_LOADER = new InjectionToken("HammerLoader");
var HammerGestureConfig = class {
  constructor() {
    this.events = [];
    this.overrides = {};
  }
  buildHammer(element) {
    const mc = new Hammer(element, this.options);
    mc.get("pinch").set({ enable: true });
    mc.get("rotate").set({ enable: true });
    for (const eventName in this.overrides) {
      mc.get(eventName).set(this.overrides[eventName]);
    }
    return mc;
  }
};
HammerGestureConfig.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "15.0.0-next.6", ngImport: core_exports, type: HammerGestureConfig, deps: [], target: FactoryTarget.Injectable });
HammerGestureConfig.\u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "15.0.0-next.6", ngImport: core_exports, type: HammerGestureConfig });
\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.0-next.6", ngImport: core_exports, type: HammerGestureConfig, decorators: [{
  type: Injectable
}] });
var HammerGesturesPlugin = class extends EventManagerPlugin {
  constructor(doc, _config, console2, loader) {
    super(doc);
    this._config = _config;
    this.console = console2;
    this.loader = loader;
    this._loaderPromise = null;
  }
  supports(eventName) {
    if (!EVENT_NAMES.hasOwnProperty(eventName.toLowerCase()) && !this.isCustomEvent(eventName)) {
      return false;
    }
    if (!window.Hammer && !this.loader) {
      if (typeof ngDevMode === "undefined" || ngDevMode) {
        this.console.warn(`The "${eventName}" event cannot be bound because Hammer.JS is not loaded and no custom loader has been specified.`);
      }
      return false;
    }
    return true;
  }
  addEventListener(element, eventName, handler) {
    const zone = this.manager.getZone();
    eventName = eventName.toLowerCase();
    if (!window.Hammer && this.loader) {
      this._loaderPromise = this._loaderPromise || zone.runOutsideAngular(() => this.loader());
      let cancelRegistration = false;
      let deregister = () => {
        cancelRegistration = true;
      };
      zone.runOutsideAngular(() => this._loaderPromise.then(() => {
        if (!window.Hammer) {
          if (typeof ngDevMode === "undefined" || ngDevMode) {
            this.console.warn(`The custom HAMMER_LOADER completed, but Hammer.JS is not present.`);
          }
          deregister = () => {
          };
          return;
        }
        if (!cancelRegistration) {
          deregister = this.addEventListener(element, eventName, handler);
        }
      }).catch(() => {
        if (typeof ngDevMode === "undefined" || ngDevMode) {
          this.console.warn(`The "${eventName}" event cannot be bound because the custom Hammer.JS loader failed.`);
        }
        deregister = () => {
        };
      }));
      return () => {
        deregister();
      };
    }
    return zone.runOutsideAngular(() => {
      const mc = this._config.buildHammer(element);
      const callback = function(eventObj) {
        zone.runGuarded(function() {
          handler(eventObj);
        });
      };
      mc.on(eventName, callback);
      return () => {
        mc.off(eventName, callback);
        if (typeof mc.destroy === "function") {
          mc.destroy();
        }
      };
    });
  }
  isCustomEvent(eventName) {
    return this._config.events.indexOf(eventName) > -1;
  }
};
HammerGesturesPlugin.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "15.0.0-next.6", ngImport: core_exports, type: HammerGesturesPlugin, deps: [{ token: DOCUMENT }, { token: HAMMER_GESTURE_CONFIG }, { token: Console }, { token: HAMMER_LOADER, optional: true }], target: FactoryTarget.Injectable });
HammerGesturesPlugin.\u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "15.0.0-next.6", ngImport: core_exports, type: HammerGesturesPlugin });
\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.0-next.6", ngImport: core_exports, type: HammerGesturesPlugin, decorators: [{
  type: Injectable
}], ctorParameters: function() {
  return [{ type: void 0, decorators: [{
    type: Inject,
    args: [DOCUMENT]
  }] }, { type: HammerGestureConfig, decorators: [{
    type: Inject,
    args: [HAMMER_GESTURE_CONFIG]
  }] }, { type: Console }, { type: void 0, decorators: [{
    type: Optional
  }, {
    type: Inject,
    args: [HAMMER_LOADER]
  }] }];
} });
var HammerModule = class {
};
HammerModule.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "15.0.0-next.6", ngImport: core_exports, type: HammerModule, deps: [], target: FactoryTarget.NgModule });
HammerModule.\u0275mod = \u0275\u0275ngDeclareNgModule({ minVersion: "14.0.0", version: "15.0.0-next.6", ngImport: core_exports, type: HammerModule });
HammerModule.\u0275inj = \u0275\u0275ngDeclareInjector({ minVersion: "12.0.0", version: "15.0.0-next.6", ngImport: core_exports, type: HammerModule, providers: [
  {
    provide: EVENT_MANAGER_PLUGINS,
    useClass: HammerGesturesPlugin,
    multi: true,
    deps: [DOCUMENT, HAMMER_GESTURE_CONFIG, Console, [new Optional(), HAMMER_LOADER]]
  },
  { provide: HAMMER_GESTURE_CONFIG, useClass: HammerGestureConfig, deps: [] }
] });
\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.0-next.6", ngImport: core_exports, type: HammerModule, decorators: [{
  type: NgModule,
  args: [{
    providers: [
      {
        provide: EVENT_MANAGER_PLUGINS,
        useClass: HammerGesturesPlugin,
        multi: true,
        deps: [DOCUMENT, HAMMER_GESTURE_CONFIG, Console, [new Optional(), HAMMER_LOADER]]
      },
      { provide: HAMMER_GESTURE_CONFIG, useClass: HammerGestureConfig, deps: [] }
    ]
  }]
}] });
var DomSanitizer = class {
};
DomSanitizer.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "15.0.0-next.6", ngImport: core_exports, type: DomSanitizer, deps: [], target: FactoryTarget.Injectable });
DomSanitizer.\u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "15.0.0-next.6", ngImport: core_exports, type: DomSanitizer, providedIn: "root", useExisting: forwardRef(function() {
  return DomSanitizerImpl;
}) });
\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.0-next.6", ngImport: core_exports, type: DomSanitizer, decorators: [{
  type: Injectable,
  args: [{ providedIn: "root", useExisting: forwardRef(() => DomSanitizerImpl) }]
}] });
function domSanitizerImplFactory(injector) {
  return new DomSanitizerImpl(injector.get(DOCUMENT));
}
var DomSanitizerImpl = class extends DomSanitizer {
  constructor(_doc) {
    super();
    this._doc = _doc;
  }
  sanitize(ctx, value) {
    if (value == null)
      return null;
    switch (ctx) {
      case SecurityContext.NONE:
        return value;
      case SecurityContext.HTML:
        if (allowSanitizationBypassAndThrow(value, "HTML")) {
          return unwrapSafeValue(value);
        }
        return _sanitizeHtml(this._doc, String(value)).toString();
      case SecurityContext.STYLE:
        if (allowSanitizationBypassAndThrow(value, "Style")) {
          return unwrapSafeValue(value);
        }
        return value;
      case SecurityContext.SCRIPT:
        if (allowSanitizationBypassAndThrow(value, "Script")) {
          return unwrapSafeValue(value);
        }
        throw new Error("unsafe value used in a script context");
      case SecurityContext.URL:
        if (allowSanitizationBypassAndThrow(value, "URL")) {
          return unwrapSafeValue(value);
        }
        return _sanitizeUrl(String(value));
      case SecurityContext.RESOURCE_URL:
        if (allowSanitizationBypassAndThrow(value, "ResourceURL")) {
          return unwrapSafeValue(value);
        }
        throw new Error("unsafe value used in a resource URL context (see https://g.co/ng/security#xss)");
      default:
        throw new Error(`Unexpected SecurityContext ${ctx} (see https://g.co/ng/security#xss)`);
    }
  }
  bypassSecurityTrustHtml(value) {
    return bypassSanitizationTrustHtml(value);
  }
  bypassSecurityTrustStyle(value) {
    return bypassSanitizationTrustStyle(value);
  }
  bypassSecurityTrustScript(value) {
    return bypassSanitizationTrustScript(value);
  }
  bypassSecurityTrustUrl(value) {
    return bypassSanitizationTrustUrl(value);
  }
  bypassSecurityTrustResourceUrl(value) {
    return bypassSanitizationTrustResourceUrl(value);
  }
};
DomSanitizerImpl.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "15.0.0-next.6", ngImport: core_exports, type: DomSanitizerImpl, deps: [{ token: DOCUMENT }], target: FactoryTarget.Injectable });
DomSanitizerImpl.\u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "15.0.0-next.6", ngImport: core_exports, type: DomSanitizerImpl, providedIn: "root", useFactory: domSanitizerImplFactory, deps: [{ token: Injector }] });
\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.0-next.6", ngImport: core_exports, type: DomSanitizerImpl, decorators: [{
  type: Injectable,
  args: [{ providedIn: "root", useFactory: domSanitizerImplFactory, deps: [Injector] }]
}], ctorParameters: function() {
  return [{ type: void 0, decorators: [{
    type: Inject,
    args: [DOCUMENT]
  }] }];
} });
var VERSION = new Version("15.0.0-next.6");

export {
  BrowserDomAdapter,
  TRANSITION_ID,
  BrowserGetTestability,
  EVENT_MANAGER_PLUGINS,
  EventManager,
  SharedStylesHost,
  DomSharedStylesHost,
  NAMESPACE_URIS,
  shimContentAttribute,
  shimHostAttribute,
  flattenStyles,
  DomRendererFactory2,
  DomEventsPlugin,
  KeyEventsPlugin,
  bootstrapApplication,
  createApplication,
  provideProtractorTestingSupport,
  initDomAdapter,
  INTERNAL_BROWSER_PLATFORM_PROVIDERS,
  platformBrowser,
  BrowserModule,
  Meta,
  Title,
  enableDebugTools,
  disableDebugTools,
  escapeHtml,
  makeStateKey,
  TransferState,
  BrowserTransferStateModule,
  By,
  HAMMER_GESTURE_CONFIG,
  HAMMER_LOADER,
  HammerGestureConfig,
  HammerGesturesPlugin,
  HammerModule,
  DomSanitizer,
  DomSanitizerImpl,
  VERSION
};
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @license Angular v15.0.0-next.6
 * (c) 2010-2022 Google LLC. https://angular.io/
 * License: MIT
 */
//# sourceMappingURL=chunk-KM23KMKZ.js.map
